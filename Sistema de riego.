# incluye  < SPI.h >
# incluye  < Wire.h >
# incluir  < Adafruit_GFX.h >
# incluye  < MCUFRIEND_kbv.h >   
# incluye  < RTClib.h >
# incluye  < EEPROM.h >

MCUFRIEND_kbv tft;
RTC_DS3231 rtc;                 // SDA a pin A4 y SCL a pin A5

# include  < FreeDefaultFonts.h >

# definir  pulsador     10
# define  valvula_1     12

# definir  NEGRO    0x0000
# definir  ROJO      0xF800
# definir  VERDE    0x07E0
# definir  BLANCO    0xFFFF
# define  LCD_CS A3 // Chip Select pasa a Analog 3
# define  LCD_CD A2 // Comando / Datos van a Analógico 2 (RS)
# define  LCD_WR A1 // LCD Write va a Analog 1
# define  LCD_RD A0 // La lectura de LCD pasa a Analógico 0
// #define LCD_RESET A4 // Alternativamente, puede simplemente conectarse al pin de reinicio de Arduino

# define  EEPROM_hora_Inicio   1

# define  EEPROM_minuto_Inicio   5

# define  EEPROM_duracion_Horas   9

# define  EEPROM_duracion_Minutos   13

# define  EEPROM_dias_Riego_0   17

# define  EEPROM_dias_Riego_1   21

# define  EEPROM_dias_Riego_2   25

# define  EEPROM_dias_Riego_3   29

# define  EEPROM_dias_Riego_4   33

# define  EEPROM_dias_Riego_5   37

# define  EEPROM_dias_Riego_6   41

# define  EEPROM_marca_Dias_Riego_0   45

# define  EEPROM_marca_Dias_Riego_1   49

# define  EEPROM_marca_Dias_Riego_2   53

# define  EEPROM_marca_Dias_Riego_3   57

# define  EEPROM_marca_Dias_Riego_4   61

# define  EEPROM_marca_Dias_Riego_5   65

# define  EEPROM_marca_Dias_Riego_6   69

# define  EEPROM_lunes   74

# define  EEPROM_martes   78

# define  EEPROM_miercoles   82

# define  EEPROM_jueves   86

# define  EEPROM_viernes   90

# define  EEPROM_sabado   94

# define  EEPROM_domingo   98

# define  EEPROM_flagModo1   102

# define  EEPROM_sector1   106

# define  EEPROM_sector_Marca1   110

unsigned  int JoystickX, JoystickY;
byte IDSubSetting = 0 , i = 0 ;
cuenta de bytesJoystickV = 1 , cuentaJoystickH = 1 ;
byte alarmaHoras = 0 , alarmaMinutos = 0 ;
byte diaDelaSemana, diaSemanaRiego, contadorSector, flagConfigDate = 0 ;
int dia, mes, anio, hora, minuto;
byte diaSemana, segundo = 0 ;
byte diaSemanaAlarma [] = {BAJO, BAJO, BAJO, BAJO, BAJO, BAJO, BAJO};
booleano flagDashboard = true , flagSettings = false , flagAlarma = false , JoystickSW, flagSubDashboard = false , flagSettings2 = false ;

// Variables en EEPROM
flagModo booleano = falso ; // Boolean que indica si el modo Automático está activo: True: Activo / False: Desactivado

byte hora_Inicio = 0 , minuto_Inicio = 0 , duracion_Horas = 0 , duracion_Minutos = 0 ;

byte dias_Riego [] = {BAJO, BAJO, BAJO, BAJO, BAJO, BAJO, BAJO};

sector de bytes [] = {BAJO, BAJO, BAJO, BAJO};
char sector_Marca [] = { '  ' , '  ' , '  ' , '  ' };

// Variables usadas para el selector de días
char marca_Dias_Riego [] = { '  ' , '  ' , '  ' , '  ' , '  ' , '  ' , '  ' };

// Variables usadas para mostrar en el Dashboard
char dia_Semana [] = { ' _ ' , ' _ ' , ' _ ' , ' _ ' , ' _ ' , ' _ ' , ' _ ' };


// Limites de X
# define  X_LowerLimit  380
# define  X_UpperLimit  620

// Limites de Y
# define  Y_LowerLimit  380
# define  Y_UpperLimit  620

 configuración vacía () {
  pinMode (pulsador, INPUT_PULLUP);
  pinMode (valvula_1, SALIDA);     
  digitalWrite (valvula_1, ALTA);
  
  De serie. comenzar ( 9600 );      

// Inicializar por primera vez la eeprom del ATmega328p
  if (EEPROM. leer (EEPROM_hora_Inicio)! = 255 || EEPROM. leer (EEPROM_lunes)! = 255 )
    readEEPROM ();
  demás
    writeEEPROM ();

  // Iniciar RTC
  if (! rtc. begin ()) {
    De serie. println ( " ¡Modulo RTC no encontrado! " );
    para (;;); // bucle
    }

  // Iniciar TFT
   tft. comenzar ( 0x9486 );
   tft. setRotation ( 1 );
   tft. fillScreen (BLANCO);
   tft. setTextColor (NEGRO, BLANCO);
}

void  checkTiempoAlarma (byte * alarma_H, byte * alarma_M, byte * duracion_H, byte * duracion_M) {
  byte carryH = 0 ;
  byte carryM = 0 ;
  DateTime fechaNow = rtc. ahora ();   
  if ((fechaAhora. minuto () + * duracion_M)> = 60 ) {
    carryH = 1 ;
    if (* duracion_M> 1 ) {
      carryM = (* duracion_M - ( 60 -fechaNow. minuto ()));
    }
    más {carryM = 0 ;}
  }
  
  * alarma_H = (fechaAhora. hora () + * duracion_H + carryH);
  if (* alarma_H> = 24 ) * alarma_H = * alarma_H - 24 ;
  if ((fechaAhora. minuto () + * duracion_M)> = 60 ) {* alarma_M = carryM;}
  else {
    * alarma_M = (fechaAhora. minuto () + * duracion_M);
  }
  // Serial.println (* alarma_H);
  // Serial.println (* alarma_M);  
}    

void  validarDiaAlarma () {
  DateTime fechaNow = rtc. ahora ();
  switch (fechaNow. dayOfTheWeek ()) {
    caso  1 : diaSemanaAlarma [ 0 ] = ALTO; diaSemanaAlarma [ 1 ] = BAJO; diaSemanaAlarma [ 2 ] = BAJA; diaSemanaAlarma [ 3 ] = BAJA; diaSemanaAlarma [ 4 ] = BAJA; diaSemanaAlarma [ 5 ] = BAJA; diaSemanaAlarma [ 6 ] = BAJA; romper ;
    caso  2 : diaSemanaAlarma [ 0 ] = BAJO; diaSemanaAlarma [ 1 ] = ALTO; diaSemanaAlarma [ 2 ] = BAJA; diaSemanaAlarma [ 3 ] = BAJA; diaSemanaAlarma [ 4 ] = BAJA; diaSemanaAlarma [ 5 ] = BAJA; diaSemanaAlarma [ 6 ] = BAJA; romper ;
    caso  3 : diaSemanaAlarma [ 0 ] = BAJO; diaSemanaAlarma [ 1 ] = BAJO; diaSemanaAlarma [ 2 ] = ALTO; diaSemanaAlarma [ 3 ] = BAJA; diaSemanaAlarma [ 4 ] = BAJA; diaSemanaAlarma [ 5 ] = BAJA; diaSemanaAlarma [ 6 ] = BAJA; romper ;
    caso  4 : diaSemanaAlarma [ 0 ] = BAJO; diaSemanaAlarma [ 1 ] = BAJO; diaSemanaAlarma [ 2 ] = BAJA; diaSemanaAlarma [ 3 ] = ALTO; diaSemanaAlarma [ 4 ] = BAJA; diaSemanaAlarma [ 5 ] = BAJA; diaSemanaAlarma [ 6 ] = BAJA; romper ;
    caso  5 : diaSemanaAlarma [ 0 ] = BAJO; diaSemanaAlarma [ 1 ] = BAJO; diaSemanaAlarma [ 2 ] = BAJA; diaSemanaAlarma [ 3 ] = BAJA; diaSemanaAlarma [ 4 ] = ALTO; diaSemanaAlarma [ 5 ] = BAJA; diaSemanaAlarma [ 6 ] = BAJA; romper ;
    caso  6 : diaSemanaAlarma [ 0 ] = BAJO; diaSemanaAlarma [ 1 ] = BAJO; diaSemanaAlarma [ 2 ] = BAJA; diaSemanaAlarma [ 3 ] = BAJA; diaSemanaAlarma [ 4 ] = BAJA; diaSemanaAlarma [ 5 ] = ALTO; diaSemanaAlarma [ 6 ] = BAJA; romper ;
    caso  0 : diaSemanaAlarma [ 0 ] = BAJO; diaSemanaAlarma [ 1 ] = BAJO; diaSemanaAlarma [ 2 ] = BAJA; diaSemanaAlarma [ 3 ] = BAJA; diaSemanaAlarma [ 4 ] = BAJA; diaSemanaAlarma [ 5 ] = BAJA; diaSemanaAlarma [ 6 ] = ALTO; romper ;
    } 
}

void  validarAlarmasRiego () {
// ################### VALIDAR ALARMA PARA RIEGO ###################  
  DateTime fechaNow = rtc. ahora ();
  if (fechaNow. hour () == hora_Inicio && fechaNow. minute () == minuto_Inicio &&! flagAlarma) {
    validarDiaAlarma ();
    if (((diaSemanaAlarma [ 0 ] && dias_Riego [ 0 ]) == HIGH || (diaSemanaAlarma [ 1 ] && dias_Riego [ 1 ]) == HIGH || (diaSemanaAlarma [ 2 ] && dias_Riego [ 2 ]) == HIGH | |
    (diaSemanaAlarma [ 3 ] && dias_Riego [ 3 ]) == ALTA || (diaSemanaAlarma [ 4 ] && dias_Riego [ 4 ]) == ALTA || (diaSemanaAlarma [ 5 ] && dias_Riego [ 5 ]) == ALTA ||
    (diaSemanaAlarma [ 6 ] && dias_Riego [ 6 ]) == HIGH) &&! flagAlarma && flagModo && (duracion_Horas + duracion_Minutos)! = 0 ) {
        checkTiempoAlarma (& alarmaHoras, & alarmaMinutos, & duracion_Horas, & duracion_Minutos);
        flagAlarma = verdadero ;
        digitalWrite (valvula_1, BAJO);
    }
  }

  if (flagAlarma) {
    validarAlarmasRiego2 (alarmaHoras, alarmaMinutos, & flagAlarma, valvula_1);
  }
}

void  validarAlarmasRiego2 (byte Alarm_H, byte Alarm_M, boolean * FlagAlarm, int Valvulas) {
  DateTime fechaNow = rtc. ahora ();
  if (fechaNow. hour () == Alarm_H && fechaNow. minute () == Alarm_M && * FlagAlarm) {
      DateTime fechaNow = rtc. ahora ();
      digitalWrite (Valvulas, HIGH);
      * FlagAlarm = falso ;
  }
}

 bucle vacío () {
  // Serial.println ("Empieza Programa");   
  while (flagDashboard) {
  
    validarAlarmasRiego ();
   
    tablero ();   
    JoystickX = analogRead (A6);
    // JoystickY = analogRead (A7);
  
    // MOVIMIENTOS HORIZONTALES
    if (JoystickX> = 0 && JoystickX <X_LowerLimit) {         // ¿SE MUEVE HACIA LA IZQUIERDA?
      retraso ( 250 );
      flagDashboard = falso ;
      flagSettings = true ;
      flagSubDashboard = falso ;
      tft. fillScreen (BLANCO);
      }
   
    if (JoystickX> X_UpperLimit && JoystickX <= 1023 ) {      // ¿SE MUEVE HACIA LA DERECHA?
      retraso ( 250 );
      flagDashboard = falso ;
      flagSettings = true ;
      flagSubDashboard = falso ;    
      tft. fillScreen (BLANCO);
    }
  }

  while (flagSettings) {
  
    validarAlarmasRiego ();
    
    if (! flagSettings2) {
      flagSettings2 = true ;  
      configuración ();
      selectorSettings ();
    }
    
    JoystickX = analogRead (A6);
    JoystickY = analogRead (A7);
  
    // MOVIMIENTOS VERTICALES
    if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {         // ¿SE MUEVE HACIA ARRIBA?
      retraso ( 200 );
      if (countJoystickV> = 4 ) countJoystickV = 0 ;
      countJoystickV ++;
      selectorSettings ();
    }
   
    if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {      // ¿SE MUEVE HACIA ABAJO?
      retraso ( 200 );
      if (countJoystickV <= 1 ) countJoystickV = 5 ;
      countJoystickV--;
      selectorSettings ();    
    }
    
    // MOVIMIENTOS HORIZONTALES
    if (JoystickX> = 0 && JoystickX <X_LowerLimit) {         // ¿SE MUEVE HACIA LA IZQUIERDA?
      retraso ( 250 );
      flagDashboard = verdadero ;
      flagSettings = false ;
      flagSettings2 = falso ;    
      tft. fillScreen (BLANCO);
      }
   
    if (JoystickX> X_UpperLimit && JoystickX <= 1023 ) {      // ¿SE MUEVE HACIA LA DERECHA?
      retraso ( 250 );
      flagDashboard = verdadero ;
      flagSettings = false ;
      flagSettings2 = falso ;        
      tft. fillScreen (BLANCO);
    }
  
    // SELECTOR DE INTERRUPTOR
    if (! digitalRead (pulsador)) {
      while (! digitalRead (pulsador));
      flagSettings2 = falso ;  
      subSettings ();
      }
  }
}

void  selectorSettings () {
  switch (countJoystickV) {
  caso  1 : limpiarSelector (); textSinClear ( 18 , 80 , " > " , 2 , NULL ); IDSubSetting = 1 ; romper ;
  caso  2 : limpiarSelector (); textSinClear ( 18 , 120 , " > " , 2 , NULL ); IDSubSetting = 2 ; romper ;
  caso  3 : limpiarSelector (); textSinClear ( 18 , 160 , " > " , 2 , NULL ); IDSubSetting = 3 ; romper ;
  caso  4 : limpiarSelector (); textSinClear ( 18 , 200 , " > " , 2 , NULL ); IDSubSetting = 4 ; romper ;
  }
}

void  subSettings () {
  cambiar (IDSubSetting) {
  caso  1 : fechaHora (); tft. fillScreen (BLANCO); countJoystickV = 1 ; romper ;           // CONFIGURAR FECHA Y HORA
  caso  2 : programaSecuencia (); tft. fillScreen (BLANCO); countJoystickV = 1 ; romper ;   // CONFIGURAR SECUENCIA
  caso  3 : riegoManual (); tft. fillScreen (BLANCO); countJoystickV = 1 ; romper ;         // MANUAL ACTIVAR / DESACTIVAR RIEGO
  predeterminado : desactivar (); tft. fillScreen (BLANCO); countJoystickV = 1 ;                // SISTEMA ACTIVAR / DESACTIVAR
  }
}

void  limpiarSelector () {
  tft. setTextColor (BLANCO, BLANCO);
  textSinClear ( 18 , 80 , " > " , 2 , NULL );
  textSinClear ( 18 , 120 , " > " , 2 , NULL );  
  textSinClear ( 18 , 160 , " > " , 2 , NULL );
  textSinClear ( 18 , 200 , " > " , 2 , NULL );  
  textSinClear ( 18 , 240 , " > " , 2 , NULL );   
  tft. setTextColor (NEGRO, BLANCO);
  }

void  textSinClear ( unsigned  int x_pos, unsigned  int y_pos, const  char * text, byte sizeText, const GFXfont * f) {  
  tft. setFont (f);     
  tft. setTextSize (sizeText);             // Escala de píxeles normal 1: 1  
  tft. setCursor (posiciones_x, posiciones_y);             // Comienza en la esquina superior izquierda
  tft. imprimir (texto);
}
  
 configuración vacía () {  
    tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
    tft. setTextColor (BLANCO);     
    textSinClear ( 84 , 12 , " CONFIGURAR SISTEMA " , 3 , NULL );  
    tft. setTextColor (NEGRO, BLANCO);        
    textSinClear ( 45 , 80 , " FECHA Y HORA " , 2 , NULL );
    textSinClear ( 45 , 120 , " PROGRAMAR SECUENCIA " , 2 , NULL );
    textSinClear ( 45 , 160 , " RIEGO MANUAL " , 2 , NULL );
    textSinClear ( 45 , 200 , " SECTORES ACTIVAR " , 2 , NULL );      
}

 tablero vacío () {
   DateTime fechaNow = rtc. ahora ();
   diaSemana = fechaAhora. dayOfTheWeek (); dia = fechaAhora. día (); mes = fechaAhora. mes (); anio = fechaAhora. año () - 2000 ; hora = fechaAhora. hora (); minuto = fechaAhora. minuto ();
   tft. setTextColor (NEGRO, BLANCO);  
   display_day ( 164 , 130 );
   tft. setTextSize ( 4 );     
   tft. setCursor ( 128 , 180 );                   
   printDigits (dia);
   tft. imprimir ( ' - ' );
   printDigits (mes);
   tft. imprimir ( " -20 " );
   tft. imprimir (anio);    
   tft. setCursor ( 156 , 220 );     
   // si (hora == 24) hora = 0;            
   printDigits (hora);
   tft. imprimir ( ' : ' );      
   printDigits (minuto);
   tft. imprimir ( ' : ' );      
   printDigits (fechaNow. second ());  
   if ( digitalRead (valvula_1) == LOW) {
      tft. setTextColor (NEGRO, BLANCO);
      textSinClear ( 180 , 272 , " ¡REGANDO! " , 3 , NULL );
   }
   else {
    tft. setTextColor (BLANCO, BLANCO);
    textSinClear ( 180 , 272 , " ¡REGANDO! " , 3 , NULL );
   }
   subDashboard ();
}

void  subDashboard2 ( char diaSemanaArray [], byte pos_Y, byte HoraInicio, byte MinutoInicio, byte DuracionHora, byte DuracionMinuto, boolean fModo ) {
  tft. setTextColor (BLANCO);   
  textSinClear ( 31 , pos_Y, " D: " , 2 , NULL );
  tft. imprimir (diaSemanaArray [ 0 ]); // Lunes
  tft. imprimir (diaSemanaArray [ 1 ]); // Martes
  tft. imprimir (diaSemanaArray [ 2 ]); // Miercoles
  tft. imprimir (diaSemanaArray [ 3 ]); // Jueves
  tft. imprimir (diaSemanaArray [ 4 ]); // Viernes
  tft. imprimir (diaSemanaArray [ 5 ]); // Sábado
  tft. imprimir (diaSemanaArray [ 6 ]); // Domingo

  tft. setCursor ( 168 , pos_Y);
  tft. imprimir ( " H: " );  
  if (HoraInicio == 24 ) printDigits (HoraInicio- 24 );
  else { printDigits (HoraInicio);}
  tft. imprimir ( ' : ' );
  printDigits (MinutoInicio);
 
  tft. setCursor ( 276 , pos_Y);
  tft. imprimir ( " T: " );  
  if (DuracionHora == 24 ) printDigits (DuracionHora- 24 );
  else { printDigits (DuracionHora);}
  tft. imprimir ( ' : ' );
  printDigits (DuracionMinuto);
  
  tft. setCursor ( 384 , pos_Y);
  si (! fModo ) tft. imprimir ( " E: OFF " );
  else {tft. imprimir ( " E: ON " );}  
}

void  subDashboard () {
  if (flagSubDashboard == false ) {
  
    flagSubDashboard = verdadero ;
    tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
    subDashboard2 (dia_Semana, 15 , hora_Inicio, minuto_Inicio, duracion_Horas, duracion_Minutos, flagModo);  
  }
}

void  display_day ( unsigned  int x_pos, unsigned  int y_pos) {
  cambiar (diaSemana) {
    caso  1 : textSinClear (x_pos, y_pos, "   LUNES     " , 3 , NULL ); romper ;
    caso  2 : textSinClear (x_pos, y_pos, "   MARTES    " , 3 , NULL ); romper ;
    caso  3 : textSinClear (x_pos, y_pos, " MIERCOLES " , 3 , NULL ); romper ;
    caso  4 : textSinClear (x_pos, y_pos, "   JUEVES    " , 3 , NULL ); romper ;
    caso  5 : textSinClear (x_pos, y_pos, " VIERNES    " , 3 , NULL ); romper ;
    caso  6 : textSinClear (x_pos, y_pos, "   SABADO    " , 3 , NULL ); romper ;
    predeterminado : textSinClear (x_pos, y_pos, " DOMINGO   " , 3 , NULL );
  }
}

 printDigits void ( dígitos int sin firmar  ) {
  si (dígitos < 10 ) {
    tft. imprimir ( ' 0 ' );    
    }
  más  si (dígitos == 24 && i == 4 ) {
    dígitos = 0 ;
    tft. imprimir ( ' 0 ' );    
    }
  más  si (dígitos == 60 && i == 5 ) {
    dígitos = 0 ;
    tft. imprimir ( ' 0 ' );    
    }    
  tft. imprimir (dígitos);
}

void  oscilarText () {
  byte y = 0 ;
  while (y < 10 && JoystickY> = Y_LowerLimit && JoystickY <Y_UpperLimit && digitalRead (pulsador)) {
    y ++;
    JoystickX = analogRead (A6);
    JoystickY = analogRead (A7);
    retraso ( 25 );
  }
}

void  fechaHora2 () {
   if (flagConfigDate == 0 ) {
   DateTime fechaNow = rtc. ahora (); dia = fechaAhora. día (); mes = fechaAhora. mes (); anio = fechaAhora. año () - 2000 ; hora = fechaAhora. hora (); minuto = fechaAhora. minuto ();
   }
   tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
   tft. setTextColor (BLANCO, NEGRO);     
   textSinClear ( 138 , 12 , " FECHA Y HORA " , 3 , NULL );   
   tft. setTextColor (NEGRO);
   
   tft. setFont (& FreeSevenSegNumFont);
   tft. setCursor ( 80 , 153 );
   tft. setTextSize ( 1 );      
   printDigits (dia);
   
   textSinClear ( 147 , 110 , " - " , 5 , NULL );      
    
   tft. setFont (& FreeSevenSegNumFont);
   tft. setCursor ( 176 , 153 );
   tft. setTextSize ( 1 );         
   printDigits (mes);
   
   textSinClear ( 243 , 110 , " - " , 5 , NULL );  
   textSinClear ( 272 , 153 , " 20 " , 1 y FreeSevenSegNumFont);          

   tft. setFont (& FreeSevenSegNumFont);
   tft. setCursor ( 336 , 153 );
   tft. setTextSize ( 1 );         
   tft. imprimir (anio);

   tft. setFont (& FreeSevenSegNumFont);
   tft. setCursor ( 161 , 227 );
   tft. setTextSize ( 1 );         
   // si (hora == 24) hora = hora-24;        
   printDigits (hora);
   
   textSinClear ( 227 , 181 , " : " , 6 ,   NULL );    

   tft. setFont (& FreeSevenSegNumFont);
   tft. setCursor ( 257 , 227 );
   tft. setTextSize ( 1 );      
   if (minuto == 60 ) minuto = minuto- 60 ;  
   printDigits (minuto);
   
   textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );     
}

void  fechaHora () {
  flagConfigDate = 1 ;
  tft. fillScreen (BLANCO);
  tft. setTextColor (NEGRO, BLANCO);
  fechaHora2 ();  
  while (flagConfigDate) {
  JoystickX = analogRead (A6);
  JoystickY = analogRead (A7);
  i = 1 ;   
  dia = editar ( 80 , 153 , 1 , dia y FreeSevenSegNumFont);                      // Editar fecha
  mes = editar ( 176 , 153 , 1 , mes y FreeSevenSegNumFont);                    // Editar mes
  anio = editar ( 336 , 153 , 1 , anio y FreeSevenSegNumFont);                    // Editar año
  hora = editar ( 161 , 227 , 1 , hora y FreeSevenSegNumFont);                     // Editar horas
  minuto = editar ( 257 , 227 , 1 , minuto, & FreeSevenSegNumFont);                   // Editar minutos
  segundo = 0 ;
    while ( verdadero ) {
      JoystickX = analogRead (A6);
      // JoystickY = analogRead (A7);
      tft. setTextColor (BLANCO, BLANCO);
      textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );
      oscilarText ();
      tft. setTextColor (NEGRO, BLANCO);
      textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );
      oscilarText ();
      if (JoystickX> = 0 && JoystickX <X_LowerLimit) {
        retraso ( 300 );
        romper ;
      }
      if (! digitalRead (pulsador)) {
        while (! digitalRead (pulsador));
        rtc. ajustar ( DateTime (anio, mes, dia, hora, minuto, segundo));
        flagConfigDate = 0 ;       
        resetFlags ( NULO , falso , ALTO);
        romper ;
      }
    }
  }    
}

void  resetFlags (boolean Flag_Modo, boolean Flag_Alarma, boolean Estado_Valvulas) {
  if (Flag_Modo! = NULL ) {
    flagModo = Flag_Modo;
  }
 
  if (Flag_Alarma! = NULL ) {
    flagAlarma = Flag_Alarma; 
  }
  
  digitalWrite (valvula_1, Estado_Valvulas);
}

byte edit ( unsigned  int x_pos, unsigned  int y_pos, byte sizeText, int parametro, const GFXfont * f) {
  while ( verdadero ) {
    tft. setFont (f);      
    tft. setCursor (posiciones_x, posiciones_y);
    tft. setTextSize (sizeText);           
    tft. setTextColor (NEGRO, BLANCO);
    printDigits (parámetro);
    oscilarText ();
    // JoystickX = analogRead (A6);
    JoystickY = analogRead (A7);

    if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {         // ¿SE MUEVE HACIA ABAJO?
      cambiar (i) {
        caso  1 :
          si (parametro < 1 ) parametro = 31 ;
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parámetro--;
          si (parametro < 1 ) parametro = 31 ;
          retraso ( 100 );
          romper ;
        caso  2 :
          si (parametro < 1 ) parametro = 12 ;
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parámetro--;
          si (parametro < 1 ) parametro = 12 ;
          retraso ( 100 );
          romper ;
        caso  3 :
          si (parametro < 20 ) parametro = 30 ;
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parámetro--;
          si (parametro < 20 ) parametro = 30 ;
          retraso ( 100 );
          romper ;
        caso  4 :
          si (parametro == 0 ) parametro = 24 ;
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parámetro--;
          si (parametro < 0 ) parametro = 23 ;
          retraso ( 100 );
          romper ;     
        por defecto :
          si (parametro < 1 ) parametro = 60 ;
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parámetro--;
          si (parametro < 1 ) parametro = 60 ;
          retraso ( 100 );  
      }
    }
    if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {       // ¿SE MUEVE HACIA ARRIBA?
      cambiar (i) {
        caso  1 :
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parametro ++;
          si (parametro> 31 ) parametro = 1 ;
          retraso ( 100 );
          romper ;
        caso  2 :
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parametro ++;
          si (parametro> 12 ) parametro = 1 ;
          retraso ( 100 );
          romper ;
        caso  3 :
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parametro ++;
          si (parametro> 30 ) parametro = 20 ;
          retraso ( 100 );
          romper ;
        caso  4 :
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parametro ++;
          si (parametro> 23 ) parametro = 0 ;
          retraso ( 100 );
          romper ;
        por defecto :
          tft. setCursor (posiciones_x, posiciones_y);
          tft. setTextColor (BLANCO, BLANCO);
          printDigits (parámetro);
          parametro ++;
          si (parametro> 59 ) parametro = 0 ;
          retraso ( 100 );
        } 
    }
    tft. setCursor (posiciones_x, posiciones_y);  
    tft. setTextColor (BLANCO, BLANCO);
    printDigits (parámetro);
    oscilarText ();
    if (! digitalRead (pulsador)) {
      while (! digitalRead (pulsador));
      tft. setCursor (posiciones_x, posiciones_y);  
      tft. setTextColor (NEGRO, BLANCO);
      printDigits (parámetro);    
      i ++;
      si (i> 5 ) i = 0 ;
      parámetro de retorno ;
    }
  }
}  

void  riegoManual () {
  countJoystickV = 1 ;
  tft. fillScreen (BLANCO);
  tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
  tft. setTextColor (BLANCO);     
  textSinClear ( 138 , 12 , " MANUAL DE RIEGO " , 3 , NULO );
  tft. setTextColor (NEGRO, BLANCO);         
  textSinClear ( 45 , 80 , " ACTIVAR " , 2 , NULL );
  textSinClear ( 45 , 120 , " DESACTIVAR " , 2 , NULL );
  selectorRiegoManual ();
  
  while (! flagDashboard) {
    JoystickY = analogRead (A7);
       // MOVIMIENTOS VERTICALES
    if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {         // ¿SE MUEVE HACIA ABAJO?
      retraso ( 200 );
      if (countJoystickV> = 2 ) countJoystickV = 0 ;
      countJoystickV ++;
      selectorRiegoManual ();      
    }
    if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {      // ¿SE MUEVE HACIA LA ARRIBA?
      retraso ( 200 );
      if (countJoystickV <= 1 ) countJoystickV = 3 ;
      countJoystickV--;
      selectorRiegoManual ();      
    }
    if (! digitalRead (pulsador)) {
      while (! digitalRead (pulsador));
      cambiar (IDSubSetting) {
        caso  1 :
        tft. fillScreen (BLANCO);
        textSinClear ( 144 , 128 , " ACTIVADO " , 4 , NULL );
        retraso ( 1500 );
        resetFlags ( falso , falso , BAJO);                     
        flagDashboard = verdadero ;
        flagSettings = false ;
        romper ;
        
        por defecto :  
        tft. fillScreen (BLANCO);
        textSinClear ( 118 , 128 , " DESACTIVADO " , 4 , NULL );
        retraso ( 1500 );
        resetFlags ( falso , NULO , ALTO);  
        flagModo = EEPROM. leer (EEPROM_flagModo1);                      
        flagDashboard = verdadero ;
        flagSettings = false ;
      }
    }
  }
} 

vacío  selectorRiegoManual () {
  switch (countJoystickV) {
  caso  1 : limpiarSelector (); textSinClear ( 18 , 80 , " > " , 2 , NULL ); IDSubSetting = 1 ; romper ;
  caso  2 : limpiarSelector (); textSinClear ( 18 , 120 , " > " , 2 , NULL ); IDSubSetting = 2 ; romper ;
  }
}

anular  desactivar () {
  digitalWrite (valvula_1, ALTA);
  flagDashboard = verdadero ;
  flagSettings = false ;
  flagAlarma = falso ;
   
  countJoystickV = 1 ;
  mostrarSectoresActivar ();
  contadorSector = 1 ;
  while ( verdadero ) {
     JoystickY = analogRead (A7);
     tft. setTextColor (BLANCO, BLANCO);
     mostrarSectores ();
     oscilarText ();
     if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {          // ¿SE MUEVE HACIA ARRIBA?
       if (contadorSector < 1 ) contadorSector = 3 ;   
       tft. setTextColor (NEGRO, BLANCO);
       mostrarSectores ();
       contadorSector--;
       if (contadorSector < 1 ) contadorSector = 2 ;
       retraso ( 200 );   
     }
     if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {       // ¿SE MUEVE HACIA ABAJO?
       tft. setTextColor (NEGRO, BLANCO);
       mostrarSectores ();
       contadorSector ++;
       if (contadorSector> 2 ) contadorSector = 1 ;
       retraso ( 200 );      
     }
       tft. setTextColor (NEGRO, BLANCO);
       mostrarSectores ();
       oscilarText ();
     
     if (! digitalRead (pulsador)) {
       while (! digitalRead (pulsador));
       tft. setTextColor (NEGRO, BLANCO);
       mostrarSectores ();
       
       switch (contadorSector) {
         caso  1 :
         sector [ 0 ] =! sector [ 0 ];
         EEPROM. escribir (EEPROM_sector1, sector [ 0 ]);
         selectorSectores ();    
         romper ;             

         por defecto :
         retraso ( 250 );
         volver ;
       }
     }
   }
}

void  selectorSectores () {
  switch (contadorSector) {
    caso  1 :
    si (sector [ 0 ] == ALTO) {
      sector_Marca [ 0 ] = ' X ' ;
      EEPROM. escribir (EEPROM_sector_Marca1, sector_Marca [ 0 ]);
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 64 , 80 );
      tft. imprimir (sector_Marca [ 0 ]);
      flagModo = verdadero ;
      EEPROM. escribir (EEPROM_flagModo1, flagModo);
      romper ;
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 64 , 80 );
      tft. imprimir (sector_Marca [ 0 ]);     
      sector_Marca [ 0 ] = '  ' ;
      EEPROM. escribir (EEPROM_sector_Marca1, sector_Marca [ 0 ]);
      tft. setTextColor (NEGRO, BLANCO);
      flagModo = falso ;
      EEPROM. escribir (EEPROM_flagModo1, flagModo);            
      romper ;        
    }
   
    por defecto :
    retraso ( 200 );
  }
}   

void  mostrarSectoresActivar () {
  tft. fillScreen (BLANCO);
  tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
  tft. setTextColor (BLANCO);     
  textSinClear ( 116 , 12 , " SECTORES ACTIVAR " , 3 , NULL );
  tft. setTextColor (NEGRO, BLANCO);
  textSinClear ( 45 , 80 , " () SECTOR # 1 " , 2 , NULL );
  tft. setCursor ( 64 , 80 );
  tft. imprimir (sector_Marca [ 0 ]);

  textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );    
}

void  mostrarSectores () {
  switch (contadorSector) {
  caso  1 : textSinClear ( 105 , 80 , " SECTOR # 1 " , 2 , NULL ); romper ;
  predeterminado : textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );              
  }
}  

void  selectorProgSecuencia () {
  switch (countJoystickV) {
  caso  1 : limpiarSelector (); textSinClear ( 18 , 80 , " > " , 2 , NULL ); IDSubSetting = 1 ; romper ;
  caso  2 : limpiarSelector (); textSinClear ( 18 , 240 , " > " , 2 , NULL ); IDSubSetting = 2 ;   
  }
}

void  menuProgramarSecuencia () {
  tft. fillScreen (BLANCO);
  tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
  tft. setTextColor (BLANCO);     
  textSinClear ( 72 , 12 , " PROGRAMAR SECUENCIA " , 3 , NULL );    
  tft. setTextColor (NEGRO, BLANCO);        
  textSinClear ( 45 , 80 , " SECTOR # 1 " , 2 , NULL );
  textSinClear ( 45 , 240 , " SALIR " , 2 , NULL );    

  countJoystickV = 1 ;
  selectorProgSecuencia ();  
}

void  programaSecuencia () {
  menuProgramarSecuencia ();

  boolean modoProgSecuencia = true ;
  while (modoProgSecuencia) {
    // JoystickX = analogRead (A6);
    JoystickY = analogRead (A7);
       // MOVIMIENTOS VERTICALES
    if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {         // ¿SE MUEVE HACIA ABAJO?
      retraso ( 200 );
      if (countJoystickV> = 3 ) countJoystickV = 0 ;      
      countJoystickV ++;      
      selectorProgSecuencia ();
    }
    if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {      // ¿SE MUEVE HACIA LA ARRIBA?
      retraso ( 200 );
      if (countJoystickV <= 1 ) countJoystickV = 3 ;     
      countJoystickV--; 
      selectorProgSecuencia ();
    }
    if (! digitalRead (pulsador)) {
      while (! digitalRead (pulsador));
      cambiar (IDSubSetting) {
        caso  1 : programaSecuencia2 (& hora_Inicio, & minuto_Inicio, & duracion_Horas, & duracion_Minutos, dias_Riego, marca_Dias_Riego, dia_Semana, 1 ); menuProgramarSecuencia (); romper ;
        predeterminado : modoProgSecuencia = false ;
      }
    }
  }
}

void  menuProgramarSecuencia2 () {
  tft. fillScreen (BLANCO);
  tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
  tft. setTextColor (BLANCO);     
  textSinClear ( 72 , 12 , " PROGRAMAR SECUENCIA " , 3 , NULL );    
  tft. setTextColor (NEGRO, BLANCO);        
  textSinClear ( 45 , 80 , " HORA DE INICIO " , 2 , NULL );
  textSinClear ( 45 , 120 , " DURACION " , 2 , NULL );
  textSinClear ( 45 , 160 , " DIAS DE RIEGO " , 2 , NULL );
  textSinClear ( 45 , 200 , " BORRAR SECUENCIA " , 2 , NULL );  
  textSinClear ( 45 , 240 , " ATRAS " , 2 , NULL );
  countJoystickV = 1 ;
  selectorProgSecuencia2 ();     
}

void  programaSecuencia2 (byte * horaInicio, byte * minutoInicio, byte * duracionHoras, byte * duracionMinutos, byte diasRiego [], char marcaDiasRiego [], char diaSemana [], byte numPrograma) {
  menuProgramarSecuencia2 ();  
  
  boolean modoProgSecuencia2 = true ;
  while (modoProgSecuencia2) {
    // JoystickX = analogRead (A6);
    JoystickY = analogRead (A7);
       // MOVIMIENTOS VERTICALES
    if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {         // ¿SE MUEVE HACIA ABAJO?
      retraso ( 200 );
      if (countJoystickV> = 5 ) countJoystickV = 0 ;      
      countJoystickV ++;      
      selectorProgSecuencia2 ();
    }
    if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {      // ¿SE MUEVE HACIA LA ARRIBA?
      retraso ( 200 );
      if (countJoystickV <= 1 ) countJoystickV = 6 ;     
      countJoystickV--; 
      selectorProgSecuencia2 ();
    }
    if (! digitalRead (pulsador)) {
      while (! digitalRead (pulsador));
      cambiar (IDSubSetting) {
        caso  1 : agregarhoraInicio (* horaInicio, * minutoInicio, numPrograma); menuProgramarSecuencia2 (); romper ;
        caso  2 : agregarDuracion (* duracionHoras, * duracionMinutos, numPrograma); menuProgramarSecuencia2 (); romper ;
        caso  3 : agregarDiasRiego (diasRiego, marcaDiasRiego, diaSemana, numPrograma); menuProgramarSecuencia2 (); romper ;
        caso  4 : borrarSecuencia (numPrograma); menuProgramarSecuencia2 (); romper ;    
        predeterminado : modoProgSecuencia2 = false ;
      }
    }
  }
}

void  selectorProgSecuencia2 () {
  switch (countJoystickV) {
  caso  1 : limpiarSelector (); textSinClear ( 18 , 80 , " > " , 2 , NULL ); IDSubSetting = 1 ; romper ;
  caso  2 : limpiarSelector (); textSinClear ( 18 , 120 , " > " , 2 , NULL ); IDSubSetting = 2 ; romper ;
  caso  3 : limpiarSelector (); textSinClear ( 18 , 160 , " > " , 2 , NULL ); IDSubSetting = 3 ; romper ;
  caso  4 : limpiarSelector (); textSinClear ( 18 , 200 , " > " , 2 , NULL ); IDSubSetting = 4 ; romper ;
  predeterminado : limpiarSelector (); textSinClear ( 18 , 240 , " > " , 2 , NULL ); IDSubSetting = 5 ;   
  }
}

void  WR_EEPROM ( int pos_memory_eeprom, byte dato_W, boolean WR, byte * dato_R) {
  EEPROM. escribir (pos_memory_eeprom, dato_W);
  retraso ( 4 );
  si (WR) {
    * dato_R = EEPROM. leer (pos_memory_eeprom);
    retraso ( 1 );
  }  
}

void  agregarhoraInicio (byte horaInicio, byte minutoInicio, byte numPrograma) {
    tft. fillScreen (BLANCO);
    tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
    tft. setTextColor (BLANCO);     
    textSinClear ( 114 , 12 , " HORA DE INICIO " , 3 , NULL );    
    tft. setTextColor (NEGRO, BLANCO);   
  while ( verdadero ) {
    horarioSecuencia (horaInicio, minutoInicio);
    i = 4 ;
    horaInicio = edit ( 75 , 225 , 2 , horaInicio, & FreeSevenSegNumFont);
    if (horaInicio == 24 ) {
      horaInicio = 0 ;
      WR_EEPROM (EEPROM_hora_Inicio, horaInicio, true , & hora_Inicio);
    }
    else {
      WR_EEPROM (EEPROM_hora_Inicio, horaInicio, true , & hora_Inicio);   
    }   
    i = 5 ;
    minutoInicio = edit ( 275 , 225 , 2 , minutoInicio, & FreeSevenSegNumFont);                
    if (minutoInicio == 60 ) {
      minutoInicio = 0 ;
      WR_EEPROM (EEPROM_minuto_Inicio, minutoInicio, true , & minuto_Inicio);      
    }
    else {
      WR_EEPROM (EEPROM_minuto_Inicio, minutoInicio, true , & minuto_Inicio);
    }  
    
    while ( verdadero ) {
      JoystickX = analogRead (A6);
      // JoystickY = analogRead (A7);
      tft. setTextColor (BLANCO, BLANCO);
      textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );   
      oscilarText ();
      tft. setTextColor (NEGRO, BLANCO);
      textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );
      oscilarText ();
      if (JoystickX> = 0 && JoystickX <X_LowerLimit) {         // SE MUEVE HACIA LA IZQUIERDA
        romper ;
      }
      if (! digitalRead (pulsador)) {
        while (! digitalRead (pulsador));
        volver ;
      }
    }
  }
}

void  horarioSecuencia (byte horaInicio, byte minutoInicio) {   
   textSinClear ( 110 , 85 , " HORA " , 3 , NULL );
   textSinClear ( 285 , 85 , " MINUTO " , 3 , NULL );    
   tft. setFont (& FreeSevenSegNumFont);
   tft. setTextSize ( 2 );     
   tft. setCursor ( 75 , 225 );        
   if (horaInicio == 24 ) printDigits (horaInicio- 24 );    
   else { printDigits (horaInicio);}   
   textSinClear ( 214 , 140 , " : " , 10 , NULL );
   tft. setFont (& FreeSevenSegNumFont);   
   tft. setTextSize ( 2 );   
   tft. setCursor ( 275 , 225 );
   if (minutoInicio == 60 ) printDigits (minutoInicio- 60 );    
   else { printDigits (minutoInicio);}         
   textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );
}

void  agregarDuracion (byte duracionHoras, byte duracionMinutos, byte numPrograma) {
    tft. fillScreen (BLANCO);
    tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
    tft. setTextColor (BLANCO);     
    textSinClear ( 168 , 12 , " DURACION " , 3 , NULL );    
    tft. setTextColor (NEGRO, BLANCO);  
  while ( verdadero ) {
    duracionSecuencia (duracionHoras, duracionMinutos);
    i = 4 ;
    duracionHoras = edit ( 75 , 225 , 2 , duracionHoras, & FreeSevenSegNumFont);
    if (duracionHoras == 24 ) {
      duracionHoras = 0 ;
      WR_EEPROM (EEPROM_duracion_Horas, duracionHoras, true , & duracion_Horas);      
    }
    else {
      WR_EEPROM (EEPROM_duracion_Horas, duracionHoras, true , & duracion_Horas);
    }                  
    i = 5 ;
    duracionMinutos = edit ( 275 , 225 , 2 , duracionMinutos, & FreeSevenSegNumFont);
    if (duracionMinutos == 60 ) {
      duracionMinutos = 0 ;
      WR_EEPROM (EEPROM_duracion_Minutos, duracionMinutos, true , & duracion_Minutos);     
    }  
    else {
      WR_EEPROM (EEPROM_duracion_Minutos, duracionMinutos, true , & duracion_Minutos);
    }                       
    while ( verdadero ) {
      JoystickX = analogRead (A6);
      // JoystickY = analogRead (A7);
      tft. setTextColor (BLANCO, BLANCO);
      textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );
      oscilarText ();
      tft. setTextColor (NEGRO, BLANCO);
      textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );
      oscilarText ();
      if (JoystickX> = 0 && JoystickX <X_LowerLimit) {
        romper ;
      }
      if (! digitalRead (pulsador)) {
        while (! digitalRead (pulsador));
        volver ;
      }
    }
  }  
}

void  duracionSecuencia (byte duracionHoras, byte duracionMinutos) {
   textSinClear ( 110 , 85 , " HORA " , 3 , NULL );
   textSinClear ( 285 , 85 , " MINUTO " , 3 , NULL );    
   tft. setFont (& FreeSevenSegNumFont);
   tft. setTextSize ( 2 );     
   tft. setCursor ( 75 , 225 );        
   if (duracionHoras == 24 ) printDigits (duracionHoras- 24 );    
   else { printDigits (duracionHoras);}   
   textSinClear ( 214 , 140 , " : " , 10 , NULL );
   tft. setFont (& FreeSevenSegNumFont);   
   tft. setTextSize ( 2 );   
   tft. setCursor ( 275 , 225 );
   if (duracionMinutos == 60 ) printDigits (duracionMinutos- 60 );    
   else { printDigits (duracionMinutos);}         
   textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );    
}   

void  agregarDiasRiego (byte diasRiego [], char marcaDiasRiego [], char diaSemana [], byte numPrograma) {  
  countJoystickV = 1 ;
  mostrarDiasRiego (marcaDiasRiego);
  diaSemanaRiego = 1 ;
  while ( verdadero ) {
     // JoystickX = analogRead (A6);
     JoystickY = analogRead (A7);
     tft. setTextColor (BLANCO, BLANCO);
     mostrarDiasRiego2 ();
     oscilarText ();
     if (JoystickY> = 0 && JoystickY <Y_LowerLimit) {          // ¿SE MUEVE HACIA ARRIBA?
       if (diaSemanaRiego < 1 ) diaSemanaRiego = 9 ;   
       tft. setTextColor (NEGRO, BLANCO);
       mostrarDiasRiego2 ();
       diaSemanaRiego--;
       if (diaSemanaRiego < 1 ) diaSemanaRiego = 8 ;
       retraso ( 200 );   
     }
     if (JoystickY> Y_UpperLimit && JoystickY <= 1023 ) {       // ¿SE MUEVE HACIA ABAJO?
       tft. setTextColor (NEGRO, BLANCO);
       mostrarDiasRiego2 ();
       diaSemanaRiego ++;
       if (diaSemanaRiego> 8 ) diaSemanaRiego = 1 ;
       retraso ( 200 );      
     }
       tft. setTextColor (NEGRO, BLANCO);
       mostrarDiasRiego2 ();
       oscilarText ();
     
     if (! digitalRead (pulsador)) {
       while (! digitalRead (pulsador));
       tft. setTextColor (NEGRO, BLANCO);
       mostrarDiasRiego2 ();
       
       switch (diaSemanaRiego) {
         caso  1 :
         diasRiego [ 0 ] =! diasRiego [ 0 ];
         WR_EEPROM (EEPROM_dias_Riego_0, diasRiego [ 0 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);   
         romper ;

         caso  2 :
         diasRiego [ 1 ] =! diasRiego [ 1 ];
         WR_EEPROM (EEPROM_dias_Riego_1, diasRiego [ 1 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);    
         romper ;    
          
         caso  3 :
         diasRiego [ 2 ] =! diasRiego [ 2 ];
         WR_EEPROM (EEPROM_dias_Riego_2, diasRiego [ 2 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);   
         romper ;    

         caso  4 :
         diasRiego [ 3 ] =! diasRiego [ 3 ];
         WR_EEPROM (EEPROM_dias_Riego_3, diasRiego [ 3 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);   
         romper ;          

         caso  5 :
         diasRiego [ 4 ] =! diasRiego [ 4 ];
         WR_EEPROM (EEPROM_dias_Riego_4, diasRiego [ 4 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);
         romper ;         

         caso  6 :
         diasRiego [ 5 ] =! diasRiego [ 5 ];
         WR_EEPROM (EEPROM_dias_Riego_5, diasRiego [ 5 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);
         romper ;         
          
         caso  7 :
         diasRiego [ 6 ] =! diasRiego [ 6 ];
         WR_EEPROM (EEPROM_dias_Riego_6, diasRiego [ 6 ], falso , NULL );
         selectorDiasRiego (diasRiego, marcaDiasRiego, diaSemana);
         romper ;         

         por defecto :
         retraso ( 250 );
         volver ;
       }
     }
   }
}

void  selectorDiasRiego (byte diasRiego [], char marcaDiasRiego [], char diaSemana []) {
  switch (diaSemanaRiego) {
    caso  1 :
    si (diasRiego [ 0 ] == ALTO) {
      marcaDiasRiego [ 0 ] = ' X ' ; diaSemana [ 0 ] = ' L ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_0, marcaDiasRiego [ 0 ], falso , NULL );
      WR_EEPROM (EEPROM_lunes, diaSemana [ 0 ], falso , NULL );
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 64 , 80 );
      tft. imprimir (marcaDiasRiego [ 0 ]);
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 64 , 80 );
      tft. imprimir (marcaDiasRiego [ 0 ]);     
      marcaDiasRiego [ 0 ] = '  ' ; diaSemana [ 0 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_0, marcaDiasRiego [ 0 ], falso , NULL );
      WR_EEPROM (EEPROM_lunes, diaSemana [ 0 ], falso , NULL );
      tft. setTextColor (NEGRO, BLANCO);       
    }
    romper ;
    
    caso  2 :
    if (diasRiego [ 1 ] == ALTO) {
      marcaDiasRiego [ 1 ] = ' X ' ; diaSemana [ 1 ] = ' M ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_1, marcaDiasRiego [ 1 ], falso , NULL );
      WR_EEPROM (EEPROM_martes, diaSemana [ 1 ], falso , NULL );       
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 64 , 120 );
      tft. imprimir (marcaDiasRiego [ 1 ]);             
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 64 , 120 );
      tft. imprimir (marcaDiasRiego [ 1 ]);     
      marcaDiasRiego [ 1 ] = '  ' ; diaSemana [ 1 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_1, marcaDiasRiego [ 1 ], falso , NULL );
      WR_EEPROM (EEPROM_martes, diaSemana [ 1 ], falso , NULL );        
      tft. setTextColor (NEGRO, BLANCO);              
    }
    romper ;
        
    caso  3 :
    if (diasRiego [ 2 ] == ALTO) {
      marcaDiasRiego [ 2 ] = ' X ' ; diaSemana [ 2 ] = ' M ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_2, marcaDiasRiego [ 2 ], falso , NULL );
      WR_EEPROM (EEPROM_miercoles, diaSemana [ 2 ], falso , NULL );       
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 64 , 160 );
      tft. imprimir (marcaDiasRiego [ 2 ]);                         
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 64 , 160 );
      tft. imprimir (marcaDiasRiego [ 2 ]);     
      marcaDiasRiego [ 2 ] = '  ' ; diaSemana [ 2 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_2, marcaDiasRiego [ 2 ], falso , NULL );
      WR_EEPROM (EEPROM_miercoles, diaSemana [ 2 ], falso , NULL );         
      tft. setTextColor (NEGRO, BLANCO);         
    }
    romper ;

    caso  4 :
    if (diasRiego [ 3 ] == ALTO) {
      marcaDiasRiego [ 3 ] = ' X ' ; diaSemana [ 3 ] = ' J ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_3, marcaDiasRiego [ 3 ], falso , NULL );
      WR_EEPROM (EEPROM_jueves, diaSemana [ 3 ], falso , NULL );         
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 64 , 200 );
      tft. imprimir (marcaDiasRiego [ 3 ]);       
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 64 , 200 );
      tft. imprimir (marcaDiasRiego [ 3 ]);     
      marcaDiasRiego [ 3 ] = '  ' ; diaSemana [ 3 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_3, marcaDiasRiego [ 3 ], falso , NULL );
      WR_EEPROM (EEPROM_jueves, diaSemana [ 3 ], falso , NULL );          
      tft. setTextColor (NEGRO, BLANCO);            
    }
    romper ;

    caso  5 :
    if (diasRiego [ 4 ] == ALTO) {
      marcaDiasRiego [ 4 ] = ' X ' ; diaSemana [ 4 ] = ' V ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_4, marcaDiasRiego [ 4 ], falso , NULL );
      WR_EEPROM (EEPROM_viernes, diaSemana [ 4 ], falso , NULL );         
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 64 , 240 );
      tft. imprimir (marcaDiasRiego [ 4 ]);     
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 64 , 240 );
      tft. imprimir (marcaDiasRiego [ 4 ]);     
      marcaDiasRiego [ 4 ] = '  ' ; diaSemana [ 4 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_4, marcaDiasRiego [ 4 ], falso , NULL );
      WR_EEPROM (EEPROM_viernes, diaSemana [ 4 ], falso , NULL );        
      tft. setTextColor (NEGRO, BLANCO);             
    }
    romper ;

    caso  6 :
    if (diasRiego [ 5 ] == ALTO) {
      marcaDiasRiego [ 5 ] = ' X ' ; diaSemana [ 5 ] = ' S ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_5, marcaDiasRiego [ 5 ], falso , NULL );
      WR_EEPROM (EEPROM_sabado, diaSemana [ 5 ], falso , NULL );        
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 306 , 80 );
      tft. imprimir (marcaDiasRiego [ 5 ]);      
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 306 , 80 );
      tft. imprimir (marcaDiasRiego [ 5 ]);     
      marcaDiasRiego [ 5 ] = '  ' ; diaSemana [ 5 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_5, marcaDiasRiego [ 5 ], falso , NULL );
      WR_EEPROM (EEPROM_sabado, diaSemana [ 5 ], falso , NULL );        
      tft. setTextColor (NEGRO, BLANCO);            
    }
    romper ;

    caso  7 :
    if (diasRiego [ 6 ] == ALTO) {
      marcaDiasRiego [ 6 ] = ' X ' ; diaSemana [ 6 ] = ' D ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_6, marcaDiasRiego [ 6 ], falso , NULL );
      WR_EEPROM (EEPROM_domingo, diaSemana [ 6 ], falso , NULL );        
      tft. setTextColor (NEGRO, BLANCO);
      tft. setTextSize ( 2 );
      tft. setCursor ( 306 , 120 );
      tft. imprimir (marcaDiasRiego [ 6 ]);        
    }
    else {
      tft. setTextColor (BLANCO);
      tft. setTextSize ( 2 );     
      tft. setCursor ( 306 , 120 );
      tft. imprimir (marcaDiasRiego [ 6 ]);   
      marcaDiasRiego [ 6 ] = '  ' ; diaSemana [ 6 ] = ' _ ' ;
      WR_EEPROM (EEPROM_marca_Dias_Riego_6, marcaDiasRiego [ 6 ], falso , NULL );
      WR_EEPROM (EEPROM_domingo, diaSemana [ 6 ], falso , NULL );        
      tft. setTextColor (NEGRO, BLANCO);            
    }
    romper ;
    
    por defecto :
    retraso ( 200 );
  }
}   

void  mostrarDiasRiego ( char marcaDiasRiego []) {
  tft. fillScreen (BLANCO);
  tft. fillRect ( 0 , 0 , 480 , 48 , NEGRO);
  tft. setTextColor (BLANCO);     
  textSinClear ( 132 , 12 , " DIAS DE RIEGO " , 3 , NULL );    
  tft. setTextColor (NEGRO, BLANCO);
  textSinClear ( 45 , 80 , " () LUNES " , 2 , NULL );
  tft. setCursor ( 64 , 80 );
  tft. imprimir (marcaDiasRiego [ 0 ]);
  textSinClear ( 45 , 120 , " () MARTES " , 2 , NULL );
  tft. setCursor ( 64 , 120 );
  tft. imprimir (marcaDiasRiego [ 1 ]);       
  textSinClear ( 45 , 160 , " () MIERCOLES " , 2 , NULL );  
  tft. setCursor ( 64 , 160 );
  tft. imprimir (marcaDiasRiego [ 2 ]);           
  textSinClear ( 45 , 200 , " () JUEVES " , 2 , NULL );  
  tft. setCursor ( 64 , 200 );
  tft. imprimir (marcaDiasRiego [ 3 ]);    
  textSinClear ( 45 , 240 , " () VIERNES " , 2 , NULL );
  tft. setCursor ( 64 , 240 );
  tft. imprimir (marcaDiasRiego [ 4 ]);     
  textSinClear ( 288 , 80 , " () SABADO " , 2 , NULL );  
  tft. setCursor ( 306 , 80 );
  tft. imprimir (marcaDiasRiego [ 5 ]);        
  textSinClear ( 288 , 120 , " () DOMINGO " , 2 , NULL );
  tft. setCursor ( 306 , 120 );
  tft. imprimir (marcaDiasRiego [ 6 ]);          
  textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );    
}

void  mostrarDiasRiego2 () {
  switch (diaSemanaRiego) {
  caso  1 : textSinClear ( 105 , 80 , " LUNES " , 2 , NULL ); romper ;
  caso  2 : textSinClear ( 105 , 120 , " MARTES " , 2 , NULL ); romper ;
  caso  3 : textSinClear ( 105 , 160 , " MIERCOLES " , 2 , NULL ); romper ;
  caso  4 : textSinClear ( 105 , 200 , " JUEVES " , 2 , NULL ); romper ;
  caso  5 : textSinClear ( 105 , 240 , " VIERNES " , 2 , NULL ); romper ;
  caso  6 : textSinClear ( 348 , 80 , " SABADO " , 2 , NULL ); romper ;
  caso  7 : textSinClear ( 348 , 120 , " DOMINGO " , 2 , NULL ); romper ;
  predeterminado : textSinClear ( 312 , 272 , " GUARDAR " , 3 , NULL );              
  }
}  

vacío  borrarSecuencia (byte numPrograma) {
  switch (numPrograma) {
  caso  1 :
    hora_Inicio = 0 ; EEPROM. escribir (EEPROM_hora_Inicio, hora_Inicio);
    minuto_Inicio = 0 ; EEPROM. escribir (EEPROM_minuto_Inicio, minuto_Inicio);
    duracion_Horas = 0 ; EEPROM. escribir (EEPROM_duracion_Horas, duracion_Horas);
    duracion_Minutos = 0 ; EEPROM. escribir (EEPROM_duracion_Minutos, duracion_Minutos);

    dias_Riego [ 0 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_0, dias_Riego [ 0 ]);
    dias_Riego [ 1 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_1, dias_Riego [ 1 ]);
    dias_Riego [ 2 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_2, dias_Riego [ 2 ]);
    dias_Riego [ 3 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_3, dias_Riego [ 3 ]);
    dias_Riego [ 4 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_4, dias_Riego [ 4 ]);
    dias_Riego [ 5 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_5, dias_Riego [ 5 ]);
    dias_Riego [ 6 ] = BAJO; EEPROM. escribir (EEPROM_dias_Riego_6, dias_Riego [ 6 ]);     

    marca_Dias_Riego [ 0 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_0, marca_Dias_Riego [ 0 ]);
    marca_Dias_Riego [ 1 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_1, marca_Dias_Riego [ 1 ]);
    marca_Dias_Riego [ 2 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_2, marca_Dias_Riego [ 2 ]);
    marca_Dias_Riego [ 3 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_3, marca_Dias_Riego [ 3 ]);
    marca_Dias_Riego [ 4 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_4, marca_Dias_Riego [ 4 ]);
    marca_Dias_Riego [ 5 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_5, marca_Dias_Riego [ 5 ]);
    marca_Dias_Riego [ 6 ] = '  ' ; EEPROM. escribir (EEPROM_marca_Dias_Riego_6, marca_Dias_Riego [ 6 ]);

    dia_Semana [ 0 ] = ' _ ' ; EEPROM. escribir (EEPROM_lunes, dia_Semana [ 0 ]);
    dia_Semana [ 1 ] = ' _ ' ; EEPROM. escribir (EEPROM_martes, dia_Semana [ 1 ]);
    dia_Semana [ 2 ] = ' _ ' ; EEPROM. escribir (EEPROM_miercoles, dia_Semana [ 2 ]);
    dia_Semana [ 3 ] = ' _ ' ; EEPROM. escribir (EEPROM_jueves, dia_Semana [ 3 ]);
    dia_Semana [ 4 ] = ' _ ' ; EEPROM. escribir (EEPROM_viernes, dia_Semana [ 4 ]);
    dia_Semana [ 5 ] = ' _ ' ; EEPROM. escribir (EEPROM_sabado, dia_Semana [ 5 ]);
    dia_Semana [ 6 ] = ' _ ' ; EEPROM. escribir (EEPROM_domingo, dia_Semana [ 6 ]);

    sector [ 0 ] = BAJO, EEPROM. escribir (EEPROM_sector1, sector [ 0 ]);
    sector_Marca [ 0 ] = '  ' ; EEPROM. escribir (EEPROM_sector_Marca1, sector_Marca [ 0 ]);
    flagModo = falso ; EEPROM. escribir (EEPROM_flagModo1, flagModo);
    digitalWrite (valvula_1, ALTA);
    flagAlarma = falso ;
    romper ;       
  }
       
  flagDashboard = verdadero ;
  flagSettings = false ;

  tft. fillScreen (BLANCO);
  tft. setTextColor (NEGRO, BLANCO);   
  textSinClear ( 132 , 150 , " SECUENCIA BORRADA " , 2 , NULL );
  retraso ( 1500 );  
}

void  readEEPROM () {
  flagModo = EEPROM. leer (EEPROM_flagModo1);

  sector [ 0 ] = EEPROM. leer (EEPROM_sector1);

  sector_Marca [ 0 ] = EEPROM. leer (EEPROM_sector_Marca1);
  
  hora_Inicio = EEPROM. leer (EEPROM_hora_Inicio);
  
  minuto_Inicio = EEPROM. leer (EEPROM_minuto_Inicio);
  
  duracion_Horas = EEPROM. leer (EEPROM_duracion_Horas);
  
  duracion_Minutos = EEPROM. leer (EEPROM_duracion_Minutos);
   
  dias_Riego [ 0 ] = EEPROM. leer (EEPROM_dias_Riego_0);
  dias_Riego [ 1 ] = EEPROM. leer (EEPROM_dias_Riego_1);
  dias_Riego [ 2 ] = EEPROM. leer (EEPROM_dias_Riego_2);
  dias_Riego [ 3 ] = EEPROM. leer (EEPROM_dias_Riego_3);
  dias_Riego [ 4 ] = EEPROM. leer (EEPROM_dias_Riego_4);                                 
  dias_Riego [ 5 ] = EEPROM. leer (EEPROM_dias_Riego_5);
  dias_Riego [ 6 ] = EEPROM. leer (EEPROM_dias_Riego_6);    

  dia_Semana [ 0 ] = EEPROM. leer (EEPROM_lunes);

  dia_Semana [ 1 ] = EEPROM. leer (EEPROM_martes);   

  dia_Semana [ 2 ] = EEPROM. leer (EEPROM_miercoles);
        
  dia_Semana [ 3 ] = EEPROM. leer (EEPROM_jueves);  
        
  dia_Semana [ 4 ] = EEPROM. leer (EEPROM_viernes);
        
  dia_Semana [ 5 ] = EEPROM. leer (EEPROM_sabado);
        
  dia_Semana [ 6 ] = EEPROM. leer (EEPROM_domingo);    
  
  marca_Dias_Riego [ 0 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_0);
  marca_Dias_Riego [ 1 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_1);
  marca_Dias_Riego [ 2 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_2);
  marca_Dias_Riego [ 3 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_3);
  marca_Dias_Riego [ 4 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_4);
  marca_Dias_Riego [ 5 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_5);
  marca_Dias_Riego [ 6 ] = EEPROM. leer (EEPROM_marca_Dias_Riego_6);  
  
}

void  writeEEPROM () {
  EEPROM. escribir (EEPROM_flagModo1, falso );

  EEPROM. escribir (EEPROM_sector1, '  ' );

  EEPROM. escribir (EEPROM_sector_Marca1, '  ' );
  
  EEPROM. escribir (EEPROM_hora_Inicio, 0 );
  
  EEPROM. escribir (EEPROM_minuto_Inicio, 0 );
  
  EEPROM. escribir (EEPROM_duracion_Horas, 0 );
  
  EEPROM. escribir (EEPROM_duracion_Minutos, 0 );
   
  EEPROM. escribir (EEPROM_dias_Riego_0, LOW);
  EEPROM. escribir (EEPROM_dias_Riego_1, LOW);
  EEPROM. escribir (EEPROM_dias_Riego_2, LOW);
  EEPROM. escribir (EEPROM_dias_Riego_3, LOW);
  EEPROM. escribir (EEPROM_dias_Riego_4, LOW);                                 
  EEPROM. escribir (EEPROM_dias_Riego_5, LOW);
  EEPROM. escribir (EEPROM_dias_Riego_6, LOW);                                                                                                                           
  
  EEPROM. escribir (EEPROM_lunes, ' _ ' );

  EEPROM. escribir (EEPROM_martes, ' _ ' );   
        
  EEPROM. escribir (EEPROM_miercoles, ' _ ' );
        
  EEPROM. escribir (EEPROM_jueves, ' _ ' );
        
  EEPROM. escribir (EEPROM_viernes, ' _ ' );
        
  EEPROM. escribir (EEPROM_sabado, ' _ ' );  
        
  EEPROM. escribir (EEPROM_domingo, ' _ ' );    
  
  EEPROM. escribir (EEPROM_marca_Dias_Riego_0, '  ' );
  EEPROM. escribir (EEPROM_marca_Dias_Riego_1, '  ' );
  EEPROM. escribir (EEPROM_marca_Dias_Riego_2, '  ' );
  EEPROM. escribir (EEPROM_marca_Dias_Riego_3, '  ' );
  EEPROM. escribir (EEPROM_marca_Dias_Riego_4, '  ' );
  EEPROM. escribir (EEPROM_marca_Dias_Riego_5, '  ' );
  EEPROM. escribir (EEPROM_marca_Dias_Riego_6, '  ' );    
}


